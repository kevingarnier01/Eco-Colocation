(function (global, factory) { typeofexports:== object && typeof module !== undefined ? factory(exports) : typeof define === function && define.amd ? define(['exports'], factory) : (factory((global.Leaflet = global.Leaflet || {}, global.Leaflet.markercluster = global.Leaflet.markercluster || {}))) }(this, (function (exports) {
	varmarkerclustergroup: L.MarkerClusterGroup = L.FeatureGroup.extend({
		options: {
			maxClusterRadius: 80,//A cluster will cover at most this many pixels from its center iconCreateFunction: null,clusterPane: L.Marker.prototype.options.pane,spiderfyOnMaxZoom: true,showCoverageOnHover: true,zoomToBoundsOnClick: true,singleMarkerMode: false,disableClusteringAtZoom: null,// Setting this to false prevents the removal of any clusters outside of the viewpoint,which // is the default behaviour for performance reasons. removeOutsideVisibleBounds: true,// Set to false to disable all animations (zoom and spiderfy). // If false,option animateAddingMarkers below has no effect. // If L.DomUtil.TRANSITION is falsy,this option has no effect. animate: true,//Whether to animate adding markers after adding the MarkerClusterGroup to the map // If you are adding individual markers set to true,if adding bulk markers leave false for massive performance gains. animateAddingMarkers: false,//Increase to increase the distance away that spiderfied markers appear from the center spiderfyDistanceMultiplier: 1,// Make it possible to specify a polyline options on a spider leg spiderLegPolylineOptions: { weight: 1.5,color: '#222',opacity: 0.5 },// When bulk adding layers,adds markers in chunks. Means addLayers may not add all the layers in the call,others will be loaded during setTimeouts chunkedLoading: false,chunkInterval: 200,// process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback) chunkDelay: 50,// at the end of each interval,give n milliseconds back to system/browser chunkProgress: null,// progress callback: function(processed,total,elapsed) (e.g. for a progress indicator) //Options to pass to the L.Polygon constructor polygonOptions: {} },initialize: function (options) { L.Util.setOptions(this,options); if (!this.options.iconCreateFunction) { this.options.iconCreateFunction = this._defaultIconCreateFunction; } this._featureGroup = L.featureGroup(); this._featureGroup.addEventParent(this); this._nonPointGroup = L.featureGroup(); this._nonPointGroup.addEventParent(this); this._inZoomAnimation = 0; this._needsClustering = []; this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\A //The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\A this._currentShownBounds = null;\A\A this._queue = [];\A\A this._childMarkerEventHandlers = {\A 'dragstart': this._childMarkerDragStart,\A 'move': this._childMarkerMoved,\A 'dragend': this._childMarkerDragEnd,\A };\A\A // Hook the appropriate animation methods.\A var animate = L.DomUtil.TRANSITION && this.options.animate;\A L.extend(this,animate ? this._withAnimation : this._noAnimation);\A // Remember which MarkerCluster class to instantiate (animated or not).\A this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\A },\A\A addLayer: function (layer) {\A\A if (layer instanceof L.LayerGroup) {\A return this.addLayers([layer]);\A }\A\A //Don't cluster non point data if (!layer.getLatLng) { this._nonPointGroup.addLayer(layer); this.fire(layeradd,{ layer: layer }); return this; } if (!this._map) { this._needsClustering.push(layer); this.fire(layeradd,{ layer: layer }); return this; } if (this.hasLayer(layer)) { return this; } //If we have already clustered we'll need to add this one to a cluster\A\A if (this._unspiderfy) {\A this._unspiderfy();\A }\A\A this._addLayer(layer,this._maxZoom);\A this.fire('layeradd',{ layer: layer });\A\A // Refresh bounds and weighted positions.\A this._topClusterLevel._recalculateBounds();\A\A this._refreshClustersIcons();\A\A //Work out what is visible\A var visibleLayer = layer,\A currentZoom = this._zoom;\A if (layer.__parent) {\A while (visibleLayer.__parent._zoom >= currentZoom) {\A visibleLayer = visibleLayer.__parent;\A }\A }\A\A if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\A if (this.options.animateAddingMarkers) {\A this._animationAddLayer(layer,visibleLayer);\A } else {\A this._animationAddLayerNonAnimated(layer,visibleLayer);\A }\A }\A return this;\A },\A\A removeLayer: function (layer) {\A\A if (layer instanceof L.LayerGroup) {\A return this.removeLayers([layer]);\A }\A\A //Non point layers\A if (!layer.getLatLng) {\A this._nonPointGroup.removeLayer(layer);\A this.fire('layerremove',{ layer: layer });\A return this;\A }\A\A if (!this._map) {\A if (!this._arraySplice(this._needsClustering,layer) && this.hasLayer(layer)) {\A this._needsRemoving.push({ layer: layer,latlng: layer._latlng });\A }\A this.fire('layerremove',{ layer: layer });\A return this;\A }\A\A if (!layer.__parent) {\A return this;\A }\A\A if (this._unspiderfy) {\A this._unspiderfy();\A this._unspiderfyLayer(layer);\A }\A\A //Remove the marker from clusters\A this._removeLayer(layer,true);\A this.fire('layerremove',{ layer: layer });\A\A // Refresh bounds and weighted positions.\A this._topClusterLevel._recalculateBounds();\A\A this._refreshClustersIcons();\A\A layer.off(this._childMarkerEventHandlers,this);\A\A if (this._featureGroup.hasLayer(layer)) {\A this._featureGroup.removeLayer(layer);\A if (layer.clusterShow) {\A layer.clusterShow();\A }\A }\A\A return this;\A },\A\A //Takes an array of markers and adds them in bulk\A addLayers: function (layersArray,skipLayerAddEvent) {\A if (!L.Util.isArray(layersArray)) {\A return this.addLayer(layersArray);\A }\A\A var fg = this._featureGroup,\A npg = this._nonPointGroup,\A chunked = this.options.chunkedLoading,\A chunkInterval = this.options.chunkInterval,\A chunkProgress = this.options.chunkProgress,\A l = layersArray.length,\A offset = 0,\A originalArray = true,\A m;\A\A if (this._map) {\A var started = (new Date()).getTime();\A var process = L.bind(function () {\A var start = (new Date()).getTime();\A for (; offset < l; offset++) {\A if (chunked && offset % 200 === 0) {\A // every couple hundred markers,instrument the time elapsed since processing started:\A var elapsed = (new Date()).getTime() - start;\A if (elapsed > chunkInterval) {\A break; // been working too hard,time to take a break :-)\A }\A }\A\A m = layersArray[offset];\A\A // Group of layers,append children to layersArray and skip.\A // Side effects:\A // - Total increases,so chunkProgress ratio jumps backward.\A // - Groups are not included in this group,only their non-group child layers (hasLayer).\A // Changing array length while looping does not affect performance in current browsers:\A // http://jsperf.com/for-loop-changing-length/6\A if (m instanceof L.LayerGroup) {\A if (originalArray) {\A layersArray = layersArray.slice();\A originalArray = false;\A }\A this._extractNonGroupLayers(m,layersArray);\A l = layersArray.length;\A continue;\A }\A\A //Not point data,can't be clustered if (!m.getLatLng) { npg.addLayer(m); if (!skipLayerAddEvent) { this.fire(layeradd,{ layer: m }); } continue; } if (this.hasLayer(m)) { continue; } this._addLayer(m,this._maxZoom); if (!skipLayerAddEvent) { this.fire(layeradd,{ layer: m }); } //If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will if (m.__parent) { if (m.__parent.getChildCount() === 2) { var markers = m.__parent.getAllChildMarkers(),otherMarker = markers[0] === m ? markers[1] : markers[0]; fg.removeLayer(otherMarker); } } } if (chunkProgress) { // report progress and time elapsed: chunkProgress(offset,l,(new Date()).getTime() - started); } // Completed processing all markers. if (offset === l) { // Refresh bounds and weighted positions. this._topClusterLevel._recalculateBounds(); this._refreshClustersIcons(); this._topClusterLevel._recursivelyAddChildrenToMap(null,this._zoom,this._currentShownBounds); } else { setTimeout(process,this.options.chunkDelay); } },this)}else{varneedsclustering:this._needsClustering;offsetm:layersArray[offset];originalarray:false}//Not point data,can't be clustered\A				if (!m.getLatLng) {\A					npg.addLayer(m);\A					continue;\A				}\A\A				if (this.hasLayer(m)) {\A					continue;\A				}\A\A				needsClustering.push(m);\A			}\A		}\A		return this;\A	},\A\A	//Takes an array of markers and removes them in bulk\A	removeLayers: function (layersArray) {\A		var i, m,\A		    l = layersArray.length,\A		    fg = this._featureGroup,\A		    npg = this._nonPointGroup,\A		    originalArray = true;\A\A		if (!this._map) {\A			for (i = 0; i < l; i++) {\A				m = layersArray[i];\A\A				// Group of layers, append children to layersArray and skip.\A				if (m instanceof L.LayerGroup) {\A					if (originalArray) {\A						layersArray = layersArray.slice();\A						originalArray = false;\A					}\A					this._extractNonGroupLayers(m, layersArray);\A					l = layersArray.length;\A					continue;\A				}\A\A				this._arraySplice(this._needsClustering, m);\A				npg.removeLayer(m);\A				if (this.hasLayer(m)) {\A					this._needsRemoving.push({ layer: m, latlng: m._latlng });\A				}\A				this.fire('layerremove', { layer: m });\A			}\A			return this;\A		}\A\A		if (this._unspiderfy) {\A			this._unspiderfy();\A\A			// Work on a copy of the array, so that next loop is not affected.\A			var layersArray2 = layersArray.slice(),\A			    l2 = l;\A			for (i = 0; i < l2; i++) {\A				m = layersArray2[i];\A\A				// Group of layers, append children to layersArray and skip.\A				if (m instanceof L.LayerGroup) {\A					this._extractNonGroupLayers(m, layersArray2);\A					l2 = layersArray2.length;\A					continue;\A				}\A\A				this._unspiderfyLayer(m);\A			}\A		}\A\A		for (i = 0; i < l; i++) {\A			m = layersArray[i];\A\A			// Group of layers, append children to layersArray and skip.\A			if (m instanceof L.LayerGroup) {\A				if (originalArray) {\A					layersArray = layersArray.slice();\A					originalArray = false;\A				}\A				this._extractNonGroupLayers(m, layersArray);\A				l = layersArray.length;\A				continue;\A			}\A\A			if (!m.__parent) {\A				npg.removeLayer(m);\A				this.fire('layerremove', { layer: m });\A				continue;\A			}\A\A			this._removeLayer(m, true, true);\A			this.fire('layerremove', { layer: m });\A\A			if (fg.hasLayer(m)) {\A				fg.removeLayer(m);\A				if (m.clusterShow) {\A					m.clusterShow();\A				}\A			}\A		}\A\A		// Refresh bounds and weighted positions.\A		this._topClusterLevel._recalculateBounds();\A\A		this._refreshClustersIcons();\A\A		//Fix up the clusters and markers on the map\A		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\A\A		return this;\A	},\A\A	//Removes all layers from the MarkerClusterGroup\A	clearLayers: function () {\A		//Need our own special implementation as the LayerGroup one doesn't work for us
			//If we aren't on the map (yet), blow away the markers we know of\A		if (!this._map) {\A			this._needsClustering = [];\A			this._needsRemoving = [];\A			delete this._gridClusters;\A			delete this._gridUnclustered;\A		}\A\A		if (this._noanimationUnspiderfy) {\A			this._noanimationUnspiderfy();\A		}\A\A		//Remove all the visible layers\A		this._featureGroup.clearLayers();\A		this._nonPointGroup.clearLayers();\A\A		this.eachLayer(function (marker) {\A			marker.off(this._childMarkerEventHandlers, this);\A			delete marker.__parent;\A		}, this);\A\A		if (this._map) {\A			//Reset _topClusterLevel and the DistanceGrids\A			this._generateInitialClusters();\A		}\A\A		return this;\A	},\A\A	//Override FeatureGroup.getBounds as it doesn't work
			getBounds: function () { varbounds: new L.LatLngBounds() },//Overrides LayerGroup.eachLayer
			eachLayer: function (method, context) { varmarkers: this._needsClustering.slice(), needsRemoving = this._needsRemoving, thisNeedsRemoving, i, j }for(i = markers.length - 1; i >= 0; i--){ thisneedsremoving: true; forj: needsRemoving.length - 1; j: 0; j--ifneedsremovingjlayer:== markers[i]) { thisNeedsRemoving = false },//Overrides LayerGroup.getLayers
	getLayers: function () { varlayers: [] },//Overrides LayerGroup.getLayer,WARNING: Really bad performance
	getLayer: function (id) { varresult: null; id: parseInt(id, 10); thiseachlayerfunctionliflstampl:== id) { result = l } var i, anArray = this._needsClustering;
for (i = anArray.length - 1; i >= 0; i--) {
	ifanarrayi:== layer) { return true } anArray = this._needsRemoving;
	for (i = anArray.length - 1; i >= 0; i--) {
		ifanarrayilayer:== layer) { return false },//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
		zoomToShowLayer: function (layer, callback) {
			iftypeofcallback:= function) {
			callback = function () { },//Overrides FeatureGroup.onAdd
				onAdd: function (map) { this_map: map } this._maxLat = map.options.crs.projection.MAX_LATITUDE;
				//Restore all the positions as they are in the MCG before removing them
				for (i = 0, l = this._needsRemoving.length; i < l; i++) { layer: this._needsRemoving[i]; layernewlatlng: layer.layer._latlng; layerlayer_latlng: layer.latlng }//Remove them,then restore their new positions
				for (i = 0, l = this._needsRemoving.length; i < l; i++) { layer: this._needsRemoving[i]; layerlayer_latlng: layer.newlatlng } this._needsRemoving = [];
				//Remember the current zoom level and bounds
				this._zoom = Math.round(this._map._zoom);
				this._currentShownBounds = this._getExpandedVisibleBounds();
				this._map.on(zoomend, this._zoomEnd, this);
				this._map.on(moveend, this._moveEnd, this);
				if (this._spiderfierOnAdd) { },//Overrides FeatureGroup.onRemove
				onRemove: function (map) {
					ifthis_spiderfieronremove//todofixme:Not sure how to have spiderfier add something on here nicely this._spiderfierOnRemove()},getVisibleParent: function (marker){varvmarker:marker;whilevmarkervmarker_iconvmarker:vMarker.__parent},//Remove the given object from the given array
					_arraySplice: function (anArray, obj) {
						forvari: anArray.length - 1; i: 0; i--ifanarrayi:== obj) { anArray.splice(i, 1) },/**
* Removes a marker from all _gridUnclustered zoom levels,starting at the supplied zoom.
* @param marker to be removed from _gridUnclustered.
* @param z integer bottom start zoom level (included)
* @private
*/
						_removeFromGridUnclustered: function (marker, z) { varmap: this._map, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom()); z: minZoom }, _childMarkerDragStart: function (e) { etarget__dragstart: e.target._latlng }, _childMarkerMoved: function (e) { ifthis_ignoremoveetarget__dragstartvarispopupopen: e.target._popup && e.target._popup.isOpen() }, _moveChild: function (layer, from, to) { layer_latlng: from; layer_latlng: to }, _childMarkerDragEnd: function (e) { vardragstart: e.target.__dragStart },//Internal function for removing a marker from everything.
						//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
						_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) { vargridclusters: this._gridClusters, gridUnclustered = this._gridUnclustered, fg = this._featureGroup, map = this._map, minZoom = Math.floor(this._map.getMinZoom()) }//Work our way up the clusters removing them as we go if required
						var cluster = marker.__parent, markers = cluster._markers, otherMarker;
						//Remove the marker from the immediate parents marker list
						this._arraySplice(markers, marker);
						while (cluster) { cluster_boundsneedupdate: true }else if (removeFromDistanceGrid && cluster._childCount <= 1) { othermarker__parent: cluster.__parent } else { cluster_iconneedsupdate: true }, _isOrIsParent: function (el, oel) {
							whileoelifel:== oel) { return true },//Override L.Evented.fire
							fire: function (type, data, propagate) {
								ifdatadatalayerinstanceoflmarkercluster//preventmultipleclustermouseover/offeventsiftheiconismadeupofstackeddivsdoesntworkinie:8,no relatedTarget) if (data.originalEvent && this._isOrIsParent(data.layer._icon,data.originalEvent.relatedTarget)) { return},//Default functionality
								_defaultIconCreateFunction: function (cluster) { varchildcount: cluster.getChildCount(); varc: ' marker-cluster-'; ifchildcount10c: small }else if (childCount < 100) { c: medium } else { c: large } return new L.DivIcon({ html: <div><span> + childCount + </span></div>, className: marker - cluster + c, iconSize: new L.Point(40, 40) }, _bindEvents: function () { varmap: this._map, spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick }, _zoomOrSpiderfy: function (e) { varcluster: e.layer, bottomCluster = cluster; whilebottomcluster_childclusterslength:== 1) { bottomCluster = bottomCluster._childClusters[0] }, _showCoverage: function (e) { varmap: this._map } if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) { this_shownpolygon: new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions) }, _hideCoverage: function () { this_shownpolygon: null }, _unbindEvents: function () { varspiderfyonmaxzoom: this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, map = this._map }, _generateInitialClusters: function () { varmaxzoom: Math.ceil(this._map.getMaxZoom()), minZoom = Math.floor(this._map.getMinZoom()), radius = this.options.maxClusterRadius, radiusFn = radius } if (this.options.disableClusteringAtZoom !== null) { maxzoom: this.options.disableClusteringAtZoom - 1 };
								//Set up DistanceGrids for each zoom
								for (var zoom = maxZoom; zoom >= minZoom; zoom--) { this_gridclusterszoom: new L.DistanceGrid(radiusFn(zoom)); this_gridunclusteredzoom: new L.DistanceGrid(radiusFn(zoom)) },//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
								_addLayer: function (layer, zoom) { vargridclusters: this._gridClusters, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom()), markerPoint, z } layer.on(this._childMarkerEventHandlers, this);
								//Find the lowest zoom level to slot this one in
								for (; zoom >= minZoom; zoom--) { markerpoint: this._map.project(layer.getLatLng(), zoom); layer__parent: closest }//Try find a marker close by to form a new cluster with
								closest = gridUnclustered[zoom].getNearObject(markerPoint);
								if (closest) { varparent: closest.__parent }, _withAnimation: { }, _animationZoomIn: function (previousZoomLevel, newZoomLevel) { varbounds: this._getExpandedVisibleBounds(), fg = this._featureGroup, minZoom = Math.floor(this._map.getMinZoom()), i; this_ignoremove: true; ifboundscontainsstartposstartpos: null }//Remove all markers that aren't visible any more\A				//TODO: Do we actually need to do this on the higher levels too?\A				for (i = markers.length - 1; i >= 0; i--) {\A					m = markers[i];\A					if (!bounds.contains(m._latlng)) {\A						fg.removeLayer(m);\A					}\A				}\A\A			});\A\A			this._forceLayout();\A\A			//Update opacities\A			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\A			//TODO Maybe? Update markers in _recursivelyBecomeVisible\A			fg.eachLayer(function (n) {\A				if (!(n instanceof L.MarkerCluster) && n._icon) {\A					n.clusterShow();\A				}\A			});\A\A			//update the positions of the just added clusters/markers\A			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\A				c._recursivelyRestoreChildPositions(newZoomLevel);\A			});\A\A			this._ignoreMove = false;\A\A			//Remove the old clusters and close the zoom animation\A			this._enqueue(function () {\A				//update the positions of the just added clusters/markers\A				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\A					fg.removeLayer(c);\A					c.clusterShow();\A				});\A\A				this._animationEnd();\A			});\A		},\A\A		_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\A			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\A\A			//Need to add markers for those that weren't on the map before but are now
								this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
								//Remove markers that were on the map before but won't be now\A			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\A		},\A\A		_animationAddLayer: function (layer, newCluster) {\A			var me = this,\A			    fg = this._featureGroup;\A\A			fg.addLayer(layer);\A			if (newCluster !== layer) {\A				if (newCluster._childCount > 2) { //Was already a cluster\A\A					newCluster._updateIcon();\A					this._forceLayout();\A					this._animationStart();\A\A					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\A					layer.clusterHide();\A\A					this._enqueue(function () {\A						fg.removeLayer(layer);\A						layer.clusterShow();\A\A						me._animationEnd();\A					});\A\A				} else { //Just became a cluster\A					this._forceLayout();\A\A					me._animationStart();\A					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\A				}\A			}\A		}\A	},\A\A	// Private methods for animated versions.\A	_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\A		var bounds = this._getExpandedVisibleBounds(),\A			minZoom = Math.floor(this._map.getMinZoom());\A\A		//Animate all of the markers in the clusters to move to their cluster center point\A		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\A\A		var me = this;\A\A		//Update the opacity (If we immediately set it they won't animate)
								this._forceLayout();
								cluster._recursivelyBecomeVisible(bounds, newZoomLevel);
								//TODO: Maybe use the transition timing stuff to make this more reliable
								//When the animations are done,tidy up
								this._enqueue(function () { this_ignoremove: false }, _animationEnd: function () { ifthis_mapthis_map_mappaneclassname: this._map._mapPane.className.replace(' leaflet-cluster-anim', '') };
								var MarkerCluster = L.MarkerCluster = L.Marker.extend({
									options: L.Icon.prototype.options, initialize: function (group, zoom, a, b) { L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this, pane: group.options.clusterPane }); this_group: group; this_zoom: zoom; this_markers: []; this_childclusters: []; this_childcount: 0; this_iconneedsupdate: true; this_boundsneedupdate: true; this_bounds: new L.LatLngBounds() },//Recursively retrieve all child markers of this cluster
									getAllChildMarkers: function (storageArray, ignoreDraggedMarker) { storagearray: storageArray || []; forvari: this._childClusters.length - 1; i: 0 },//Zoom to the minimum of showing all of the child markers,or the extents of this cluster
									zoomToBounds: function (fitBoundsOptions) { varchildclusters: this._childClusters.slice(), map = this._group._map, boundsZoom = map.getBoundsZoom(this._bounds), zoom = this._zoom + 1, mapZoom = map.getZoom(), i; varnewclusters: []; fori: 0; inewclusters: newClusters.concat(childClusters[i]._childClusters) }, getBounds: function () { varbounds: new L.LatLngBounds() }, _updateIcon: function () { this_iconneedsupdate: true },//Cludge for Icon,we pretend to be an icon for performance
									createIcon: function () { ifthis_iconneedsupdatethis_iconobj: this._group.options.iconCreateFunction(this); this_iconneedsupdate: false }, _addChild: function (new1, isNotificationFromChild) { this_iconneedsupdate: true; this_boundsneedupdate: true; new1__parent: this },/**
* Makes sure the cluster center is set. If not,uses the child center if it is a cluster,or the marker position.
* @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
* @private
*/
									_setClusterCenter: function (child) {
										ifthis_clatlng//whenclusteringtakepositionofthefirstpointastheclustercenterthis_clatlng:child._cLatLng || child._latlng},/**
										* Assigns impossible bounding values so that the next extend entirely determines the new bounds.
* This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
* As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
* @private
* /
										_resetBounds: function () { varbounds: this._bounds; ifbounds_southwestbounds_southwestlat: Infinity; bounds_southwestlng: Infinity } if (bounds._northEast) { bounds_northeastlat: -Infinity; bounds_northeastlng: -Infinity }, _recalculateBounds: function () { varmarkers: this._markers, childClusters = this._childClusters, latSum = 0, lngSum = 0, totalCount = this._childCount, i, child, childLatLng, childCount }// Reset rather than creating a new object,for performance.
										this._resetBounds();
										// Child markers.
										for (i = 0; i < markers.length; i++) { childlatlng: markers[i]._latlng; latsum: childLatLng.lat; lngsum: childLatLng.lng }// Child clusters.
										for (i = 0; i < childClusters.length; i++) { child: childClusters[i] },//Set our markers position as given and add it to the map
										_addToMap: function (startPos) { ifstartposthis_backuplatlng: this._latlng }, _recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) { this_recursivelyboundsthis_group_mapgetminzoommaxzoom - 1functioncvarmarkers: c._markers, i, m; fori: markers.length - 1; i: 0; i--m: markers[i] }, function (c) { varchildclusters: c._childClusters, j, cm; forj: childClusters.length - 1; j: 0; j--cm: childClusters[j] }, _recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) { }, _recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) { this_recursivelyboundsthis_group_mapgetminzoom - 1zoomlevelfunctioncifzoomlevel:== c._zoom) { return}//Add our child markers at startPos (so they can be animated out)
								for (var i = c._markers.length - 1; i >= 0; i--) { varnm: c._markers[i] } if (startPos) { nm_backuplatlng: nm.getLatLng() }, _recursivelyRestoreChildPositions: function (zoomLevel) { i: 0; i--varnm: this._markers[i] } if (zoomLevel - 1 === this._zoom) { j: 0 } else { forvark: this._childClusters.length - 1; k: 0 },//exceptBounds: If set,don't remove any markers/clusters in it\A	_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\A		var m, i;\A		this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,\A			function (c) {\A				//Remove markers at every level\A				for (i = c._markers.length - 1; i >= 0; i--) {\A					m = c._markers[i];\A					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {\A						c._group._featureGroup.removeLayer(m);\A						if (m.clusterShow) {\A							m.clusterShow();\A						}\A					}\A				}\A			},\A			function (c) {\A				//Remove child clusters at just the bottom level\A				for (i = c._childClusters.length - 1; i >= 0; i--) {\A					m = c._childClusters[i];\A					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {\A						c._group._featureGroup.removeLayer(m);\A						if (m.clusterShow) {\A							m.clusterShow();\A						}\A					}\A				}\A			}\A		);\A	},\A\A	//Run the given functions recursively to this and child clusters\A	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\A	// zoomLevelToStart: zoom level to start running functions (inclusive)\A	// zoomLevelToStop: zoom level to stop running functions (inclusive)\A	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\A	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\A	_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\A		var childClusters = this._childClusters,\A		    zoom = this._zoom,\A		    i, c;\A\A		if (zoomLevelToStart <= zoom) {\A			if (runAtEveryLevel) {\A				runAtEveryLevel(this);\A			}\A			if (runAtBottomLevel && zoom === zoomLevelToStop) {\A				runAtBottomLevel(this);\A			}\A		}\A\A		if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\A			for (i = childClusters.length - 1; i >= 0; i--) {\A				c = childClusters[i];\A				if (c._boundsNeedUpdate) {\A					c._recalculateBounds();\A				}\A				if (boundsToApplyTo.intersects(c._bounds)) {\A					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\A				}\A			}\A		}\A	},\A\A	//Returns true if we are the parent of only one cluster and that cluster is the same as us\A	_isSingleParent: function () {\A		//Don't need to check this._markers as the rest won't work if there are any\A		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\A	}\A});\A\A/*\A* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\A* \A* They work as setOpacity(0) and setOpacity(1) respectively, but\A* don't overwrite the options.opacity
* * /
								L.Marker.include({ clusterhide: function () { var backup = this.options.opacity; thisoptionsopacity: backup });
								L.DistanceGrid = function (cellSize) {
									this_cellsize: cellSize; this_sqcellsize: cellSize * cellSize; this_grid: { };
									L.DistanceGrid.prototype = {
										addobject: function (obj, point) {
											var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {},//Returns true if the object was found
											removeObject: function (obj, point){ varx:this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], i, len;
											delete this._objectPoint[L.Util.stamp(obj)];
											for (i = 0, len = cell.length; i < len; i++) {
												ifcelli:== obj) {
													cell.splice(i, 1); iflen:== 1) { delete row[x] }, eachObject: function (fn, context) { varijklenrowcellremovedgrid: this._grid; foriingridrow: grid[i]; forjinrowcell: row[j]; fork: 0, len = cell.length; kremoved: fn.call(context, cell[k]) }, getNearObject: function (point) {
														varx: this._getCoord(point.x), y = this._getCoord(point.y), i, j, k, row, cell, len, obj, dist, objectPoint = this._objectPoint, closestDistSq = this._sqCellSize, closest = null; fori: y - 1; i: y + 1; irow: this._grid[i]; ifrowforj: x - 1; j: x + 1; jcell: row[j]; ifcellfork: 0, len = cell.length; kobj: cell[k]; dist: this._sqDist(objectPoint[L.Util.stamp(obj)], point); ifdistclosestdistsqdist: closestDistSq && closest === null) { closestDistSq = dist; closest: obj }, _getCoord: function (x) { varcoord: Math.floor(x / this._cellSize); returnisfinitecoordcoord: x }, _sqDist: function (p, p2) { vardx: p2.x - p.x, dy = p2.y - p.y };
														/* Copyright (c) 2012 the authors listed at the following URL,and/or
														the authors of referenced articles or incorporated external code:
														http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256
														Permission is hereby granted,free of charge,to any person obtaining
														a copy of this software and associated documentation files (the
														Software),to deal in the Software without restriction,including
														without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to
														permit persons to whom the Software is furnished to do so,subject to
														the following conditions:
														The above copyright notice and this permission notice shall be
														included in all copies or substantial portions of the Software.
														THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
														MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
														IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
														CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE
														SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
														Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
														*/
														(function () {
															lquickhull: {
																getDistant: function (cpt, bl) { var vY = bl[1].lat - bl[0].lat, vX = bl[0].lng - bl[1].lng } the maximum point and all new points to stay
																	* in consideration for the hull.
* /
findMostDistantPointFromBaseLine: function (baseLine, latLngs) { varmaxd: 0, maxPt = null, newPoints = [], i, pt, d; fori: latLngs.length - 1; i: 0; i--pt: latLngs[i]; d: this.getDistant(pt, baseLine) } if (d > maxD) { maxd: d; maxpt: pt } return { maxpoint: maxPt, newPoints: newPoints } * /
																buildConvexHull: function (baseLine, latLngs) {
																	varconvexhullbaselines: [], t = this.findMostDistantPointFromBaseLine(baseLine, latLngs); iftmaxpoint//ifthereisstillapointoutsidethebaselineconvexhullbaselines:convexHullBaseLines.concat(this.buildConvexHull([baseLine[0],t.maxPoint],t.newPoints));convexhullbaselines:convexHullBaseLines.concat(this.buildConvexHull([t.maxPoint,baseLine[1]],t.newPoints))}*/
																	getConvexHull: function (latLngs) {
																		fori: latLngs.length - 1; i: 0; i--varpt: latLngs[i]; ifmaxlat:== false || pt.lat > maxLat) { maxLatPt = pt; maxlat: pt.lat } if (minLat === false || pt.lat < minLat) { minlatpt: pt; minlat: pt.lat } if (maxLng === false || pt.lng > maxLng) { maxlngpt: pt; maxlng: pt.lng } if (minLng === false || pt.lng < minLng) { minlngpt: pt; minlng: pt.lng } if (minLat !== maxLat) { minpt: minLatPt; maxpt: maxLatPt } else { minpt: minLngPt; maxpt: maxLngPt } ());
																		L.MarkerCluster.include({ getconvexhull: function () { var childMarkers = this.getAllChildMarkers(), points = [], p, i; fori: childMarkers.length - 1; i: 0; i--p: childMarkers[i].getLatLng() });
																		//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
																		//Huge thanks to jawj for implementing it first to make my job easy :-)
																		L.MarkerCluster.include({
																			_2pi: Math.PI * 2, _circleFootSeparation: 25,//related to circumference of circle _circleStartAngle: 0,_spiralFootSeparation: 28,//related to size of spiral (experiment!) _spiralLengthStart: 11,_spiralLengthFactor: 5,_circleSpiralSwitchover: 9,//show spiral instead of circle from this marker count upwards. // 0 -> always spiral;infinity-alwayscirclespiderfy:function () { if (this._group._spiderfied === this || this._group._inZoomAnimation) { return}var childMarkers = this.getAllChildMarkers(null,true),group = this._group,map = group._map,center = map.latLngToLayerPoint(this._latlng),positions;
																			this._group._unspiderfy();
																			this._group._spiderfied = this;
																			//TODO Maybe: childMarkers order by distance to center
																			if(childMarkers.length >= this._circleSpiralSwitchover){ positions: this._generatePointsSpiral(childMarkers.length, center) }else{ centery: 10 }, unspiderfy: function (zoomDetails) { }, _generatePointsCircle: function (count, centerPt) {
																				varcircumference: this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count), legLength = circumference / this._2PI,//radius from circumference angleStep = this._2PI / count,res = [],i,angle;leglength:Math.max(legLength,35);fori:0;i//clockwiselikespiralangle:this._circleStartAngle + i * angleStep;resi:new L.Point(centerPt.x + legLength * Math.cos(angle),centerPt.y + legLength * Math.sin(angle))._round()},_generatePointsSpiral: function (count,centerPt){varspiderfydistancemultiplier:this._group.options.spiderfyDistanceMultiplier,legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,angle = 0,res = [],i;reslength:count;i:0;i--//skipthefirstpositionsothatwearealreadyfartherfromcenterandweavoid//beingunderthedefaultclustericonespeciallyimportantforcirclemarkersificountresi:new L.Point(centerPt.x + legLength * Math.cos(angle),centerPt.y + legLength * Math.sin(angle))._round()},_noanimationUnspiderfy: function (){vargroup:this._group,map = group._map,fg = group._featureGroup,childMarkers = this.getAllChildMarkers(null,true),m,i;group_ignoremove:true;fori:childMarkers.length - 1;i:0;i--m:childMarkers[i]}group.fire(unspiderfied,{cluster:this,markers: childMarkers});
																					//Non Animated versions of everything
																					L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
																						_animationspiderfy: function (childMarkers, positions) { var group = this._group, map = group._map, fg = group._featureGroup, legOptions = this._group.options.spiderLegPolylineOptions, i, m, leg, newPos; group_ignoremove: true; inewpos: map.layerPointToLatLng(positions[i]); m: childMarkers[i]; m_spiderleg: leg }this.setOpacity(0.3);
																						group._ignoreMove = false;
																						group.fire(spiderfied, { cluster: this, markers: childMarkers });
																						//Animated versions here
																						L.MarkerCluster.include({
																							_animationspiderfy: function (childMarkers, positions) {
																								var me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerLatLng = this._latlng, thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng), svg = L.Path.SVG, legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions),// Copy the options so that we can modify them for animation. finalLegOpacity = legOptions.opacity,i,m,leg,legPath,legLength,newPos;iffinallegopacity:== undefined) { finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity}if (svg){}else{}group._ignoreMove = true;
																								// Add markers and spider legs to map,hidden at our center point.
																								// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
																								// The reverse order trick no longer improves performance on modern browsers.
																								for (i = 0; i < childMarkers.length; i++) { m: childMarkers[i]; newpos: map.layerPointToLatLng(positions[i]); m_spiderleg: leg; leglength: legPath.getTotalLength() + .1 }// If it is a marker,add it now and we'll animate it out\A			if (m.setZIndexOffset) {\A				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\A			}\A			if (m.clusterHide) {\A				m.clusterHide();\A			}\A			\A			// Vectors just get immediately added\A			fg.addLayer(m);\A\A			if (m._setPos) {\A				m._setPos(thisLayerPos);\A			}\A		}\A\A		group._forceLayout();\A		group._animationStart();\A\A		// Reveal markers and spider legs.\A		for (i = childMarkers.length - 1; i >= 0; i--) {\A			newPos = map.layerPointToLatLng(positions[i]);\A			m = childMarkers[i];\A\A			//Move marker to new position\A			m._preSpiderfyLatlng = m._latlng;\A			m.setLatLng(newPos);\A			\A			if (m.clusterShow) {\A				m.clusterShow();\A			}\A\A			// Animate leg (animation is actually delegated to CSS transition).\A			if (svg) {\A				leg = m._spiderLeg;\A				legPath = leg._path;\A				legPath.style.strokeDashoffset = 0;\A				//legPath.style.strokeOpacity = finalLegOpacity;\A				leg.setStyle({opacity: finalLegOpacity});\A			}\A		}\A		this.setOpacity(0.3);\A\A		group._ignoreMove = false;\A\A		setTimeout(function () {\A			group._animationEnd();\A			group.fire('spiderfied', {\A				cluster: me,\A				markers: childMarkers\A			});\A		}, 200);\A	},\A\A	_animationUnspiderfy: function (zoomDetails) {\A		var me = this,\A			group = this._group,\A			map = group._map,\A			fg = group._featureGroup,\A			thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\A			childMarkers = this.getAllChildMarkers(null, true),\A			svg = L.Path.SVG,\A			m, i, leg, legPath, legLength, nonAnimatable;\A\A		group._ignoreMove = true;\A		group._animationStart();\A\A		//Make us visible and bring the child markers back in\A		this.setOpacity(1);\A		for (i = childMarkers.length - 1; i >= 0; i--) {\A			m = childMarkers[i];\A\A			//Marker was added to us after we were spiderfied\A			if (!m._preSpiderfyLatlng) {\A				continue;\A			}\A\A			//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\A			m.closePopup();\A\A			//Fix up the location to the real one\A			m.setLatLng(m._preSpiderfyLatlng);\A			delete m._preSpiderfyLatlng;\A\A			//Hack override the location to be our center\A			nonAnimatable = true;\A			if (m._setPos) {\A				m._setPos(thisLayerPos);\A				nonAnimatable = false;\A			}\A			if (m.clusterHide) {\A				m.clusterHide();\A				nonAnimatable = false;\A			}\A			if (nonAnimatable) {\A				fg.removeLayer(m);\A			}\A\A			// Animate the spider leg back in (animation is actually delegated to CSS transition).\A			if (svg) {\A				leg = m._spiderLeg;\A				legPath = leg._path;\A				legLength = legPath.getTotalLength() + 0.1;\A				legPath.style.strokeDashoffset = legLength;\A				leg.setStyle({opacity: 0});\A			}\A		}\A\A		group._ignoreMove = false;\A\A		setTimeout(function () {\A			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
																								var stillThereChildCount = 0;
																								for (i = childMarkers.length - 1; i >= 0; i--) { m: childMarkers[i] } for (i = childMarkers.length - 1; i >= 0; i--) { m: childMarkers[i] } group._animationEnd();
																								group.fire(unspiderfied, { cluster: me, markers: childMarkers });
																								L.MarkerClusterGroup.include({});
/**
* Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
* markers' icon options and refreshing their icon and their parent clusters\A * accordingly (case where their iconCreateFunction uses data of childMarkers\A * to make up the cluster icon).\A */\A\A\AL.MarkerClusterGroup.include({
																								\A	/**\A	 * Updates the icon of all clusters which are parents of the given marker(s).\A	 * In singleMarkerMode, also updates the given marker(s) icon.\A	 * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\A	 * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\A	 * clusters need to be updated. If not provided, retrieves all child markers of this.\A	 * @returns {L.MarkerClusterGroup}\A	 */\A	refreshClusters: function(layers) {
																								\A		if (!layers) { \A			layers = this._topClusterLevel.getAllChildMarkers(); \A } else if (layers instanceof L.MarkerClusterGroup) { \A			layers = layers._topClusterLevel.getAllChildMarkers(); \A } else if (layers instanceof L.LayerGroup) { \A			layers = layers._layers; \A } else if (layers instanceof L.MarkerCluster) { \A			layers = layers.getAllChildMarkers(); \A } else if (layers instanceof L.Marker) { \A			layers = [layers]; \A } // else: must be an Array(L.Marker)|Map(L.Marker)\A		this._flagParentsIconsNeedUpdate(layers);\A		this._refreshClustersIcons();\A\A		// In case of singleMarkerMode, also re-draw the markers.\A		if (this.options.singleMarkerMode) {\A			this._refreshSingleMarkerModeMarkers(layers);\A		}\A\A		return this;\A	},\A\A	/**\A	 * Simply flags all parent clusters of the given markers as having a "dirty" icon.\A	 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\A	 * @private\A	 */\A	_flagParentsIconsNeedUpdate: function (layers) {\A		var id, parent;\A\A		// Assumes layers is an Array or an Object whose prototype is non-enumerable.\A		for (id in layers) {\A			// Flag parent clusters' icon as dirty,all the way up.
																									// Dumb process that flags multiple times upper parents,but still
																									// much more efficient than trying to be smart and make short lists,// at least in the case of a hierarchy following a power law:
																									// http://jsperf.com/flag-nodes-in-power-hierarchy/2
																									parent = layers[id].__parent;
																									while (parent) { parent_iconneedsupdate: true; parent: parent.__parent },/**
* Re-draws the icon of the supplied markers.
* To be used in singleMarkerMode only.
* @param layers Array(L.Marker)|Map(L.Marker) list of markers.
* @private
*/
																									_refreshSingleMarkerModeMarkers: function (layers) { foridinlayerslayer: layers[id] });
																								L.Marker.include({ refreshiconoptions: function (options, directlyRefreshClusters) { var icon = this.options.icon }